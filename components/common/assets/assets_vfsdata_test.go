// Code generated by vfsgen; DO NOT EDIT

// +build !dev

package assets

import (
	"compress/gzip"
	"net/http"
	"os"
	"reflect"
	"testing"
	"time"
)

func Test_vfsgen۰FS_Open(t *testing.T) {
	type args struct {
		path string
	}
	tests := []struct {
		name    string
		fs      vfsgen۰FS
		args    args
		want    http.File
		wantErr bool
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := tt.fs.Open(tt.args.path)
			if (err != nil) != tt.wantErr {
				t.Errorf("vfsgen۰FS.Open() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("vfsgen۰FS.Open() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_vfsgen۰CompressedFileInfo_Readdir(t *testing.T) {
	type fields struct {
		name              string
		modTime           time.Time
		compressedContent []byte
		uncompressedSize  int64
	}
	type args struct {
		count int
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		want    []os.FileInfo
		wantErr bool
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			f := &vfsgen۰CompressedFileInfo{
				name:              tt.fields.name,
				modTime:           tt.fields.modTime,
				compressedContent: tt.fields.compressedContent,
				uncompressedSize:  tt.fields.uncompressedSize,
			}
			got, err := f.Readdir(tt.args.count)
			if (err != nil) != tt.wantErr {
				t.Errorf("vfsgen۰CompressedFileInfo.Readdir() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("vfsgen۰CompressedFileInfo.Readdir() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_vfsgen۰CompressedFileInfo_Stat(t *testing.T) {
	type fields struct {
		name              string
		modTime           time.Time
		compressedContent []byte
		uncompressedSize  int64
	}
	tests := []struct {
		name    string
		fields  fields
		want    os.FileInfo
		wantErr bool
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			f := &vfsgen۰CompressedFileInfo{
				name:              tt.fields.name,
				modTime:           tt.fields.modTime,
				compressedContent: tt.fields.compressedContent,
				uncompressedSize:  tt.fields.uncompressedSize,
			}
			got, err := f.Stat()
			if (err != nil) != tt.wantErr {
				t.Errorf("vfsgen۰CompressedFileInfo.Stat() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("vfsgen۰CompressedFileInfo.Stat() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_vfsgen۰CompressedFileInfo_GzipBytes(t *testing.T) {
	type fields struct {
		name              string
		modTime           time.Time
		compressedContent []byte
		uncompressedSize  int64
	}
	tests := []struct {
		name   string
		fields fields
		want   []byte
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			f := &vfsgen۰CompressedFileInfo{
				name:              tt.fields.name,
				modTime:           tt.fields.modTime,
				compressedContent: tt.fields.compressedContent,
				uncompressedSize:  tt.fields.uncompressedSize,
			}
			if got := f.GzipBytes(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("vfsgen۰CompressedFileInfo.GzipBytes() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_vfsgen۰CompressedFileInfo_Name(t *testing.T) {
	type fields struct {
		name              string
		modTime           time.Time
		compressedContent []byte
		uncompressedSize  int64
	}
	tests := []struct {
		name   string
		fields fields
		want   string
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			f := &vfsgen۰CompressedFileInfo{
				name:              tt.fields.name,
				modTime:           tt.fields.modTime,
				compressedContent: tt.fields.compressedContent,
				uncompressedSize:  tt.fields.uncompressedSize,
			}
			if got := f.Name(); got != tt.want {
				t.Errorf("vfsgen۰CompressedFileInfo.Name() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_vfsgen۰CompressedFileInfo_Size(t *testing.T) {
	type fields struct {
		name              string
		modTime           time.Time
		compressedContent []byte
		uncompressedSize  int64
	}
	tests := []struct {
		name   string
		fields fields
		want   int64
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			f := &vfsgen۰CompressedFileInfo{
				name:              tt.fields.name,
				modTime:           tt.fields.modTime,
				compressedContent: tt.fields.compressedContent,
				uncompressedSize:  tt.fields.uncompressedSize,
			}
			if got := f.Size(); got != tt.want {
				t.Errorf("vfsgen۰CompressedFileInfo.Size() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_vfsgen۰CompressedFileInfo_Mode(t *testing.T) {
	type fields struct {
		name              string
		modTime           time.Time
		compressedContent []byte
		uncompressedSize  int64
	}
	tests := []struct {
		name   string
		fields fields
		want   os.FileMode
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			f := &vfsgen۰CompressedFileInfo{
				name:              tt.fields.name,
				modTime:           tt.fields.modTime,
				compressedContent: tt.fields.compressedContent,
				uncompressedSize:  tt.fields.uncompressedSize,
			}
			if got := f.Mode(); got != tt.want {
				t.Errorf("vfsgen۰CompressedFileInfo.Mode() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_vfsgen۰CompressedFileInfo_ModTime(t *testing.T) {
	type fields struct {
		name              string
		modTime           time.Time
		compressedContent []byte
		uncompressedSize  int64
	}
	tests := []struct {
		name   string
		fields fields
		want   time.Time
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			f := &vfsgen۰CompressedFileInfo{
				name:              tt.fields.name,
				modTime:           tt.fields.modTime,
				compressedContent: tt.fields.compressedContent,
				uncompressedSize:  tt.fields.uncompressedSize,
			}
			if got := f.ModTime(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("vfsgen۰CompressedFileInfo.ModTime() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_vfsgen۰CompressedFileInfo_IsDir(t *testing.T) {
	type fields struct {
		name              string
		modTime           time.Time
		compressedContent []byte
		uncompressedSize  int64
	}
	tests := []struct {
		name   string
		fields fields
		want   bool
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			f := &vfsgen۰CompressedFileInfo{
				name:              tt.fields.name,
				modTime:           tt.fields.modTime,
				compressedContent: tt.fields.compressedContent,
				uncompressedSize:  tt.fields.uncompressedSize,
			}
			if got := f.IsDir(); got != tt.want {
				t.Errorf("vfsgen۰CompressedFileInfo.IsDir() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_vfsgen۰CompressedFileInfo_Sys(t *testing.T) {
	type fields struct {
		name              string
		modTime           time.Time
		compressedContent []byte
		uncompressedSize  int64
	}
	tests := []struct {
		name   string
		fields fields
		want   interface{}
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			f := &vfsgen۰CompressedFileInfo{
				name:              tt.fields.name,
				modTime:           tt.fields.modTime,
				compressedContent: tt.fields.compressedContent,
				uncompressedSize:  tt.fields.uncompressedSize,
			}
			if got := f.Sys(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("vfsgen۰CompressedFileInfo.Sys() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_vfsgen۰CompressedFile_Read(t *testing.T) {
	type fields struct {
		vfsgen۰CompressedFileInfo *vfsgen۰CompressedFileInfo
		gr                        *gzip.Reader
		grPos                     int64
		seekPos                   int64
	}
	type args struct {
		p []byte
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		wantN   int
		wantErr bool
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			f := &vfsgen۰CompressedFile{
				vfsgen۰CompressedFileInfo: tt.fields.vfsgen۰CompressedFileInfo,
				gr:      tt.fields.gr,
				grPos:   tt.fields.grPos,
				seekPos: tt.fields.seekPos,
			}
			gotN, err := f.Read(tt.args.p)
			if (err != nil) != tt.wantErr {
				t.Errorf("vfsgen۰CompressedFile.Read() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if gotN != tt.wantN {
				t.Errorf("vfsgen۰CompressedFile.Read() = %v, want %v", gotN, tt.wantN)
			}
		})
	}
}

func Test_vfsgen۰CompressedFile_Seek(t *testing.T) {
	type fields struct {
		vfsgen۰CompressedFileInfo *vfsgen۰CompressedFileInfo
		gr                        *gzip.Reader
		grPos                     int64
		seekPos                   int64
	}
	type args struct {
		offset int64
		whence int
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		want    int64
		wantErr bool
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			f := &vfsgen۰CompressedFile{
				vfsgen۰CompressedFileInfo: tt.fields.vfsgen۰CompressedFileInfo,
				gr:      tt.fields.gr,
				grPos:   tt.fields.grPos,
				seekPos: tt.fields.seekPos,
			}
			got, err := f.Seek(tt.args.offset, tt.args.whence)
			if (err != nil) != tt.wantErr {
				t.Errorf("vfsgen۰CompressedFile.Seek() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if got != tt.want {
				t.Errorf("vfsgen۰CompressedFile.Seek() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_vfsgen۰CompressedFile_Close(t *testing.T) {
	type fields struct {
		vfsgen۰CompressedFileInfo *vfsgen۰CompressedFileInfo
		gr                        *gzip.Reader
		grPos                     int64
		seekPos                   int64
	}
	tests := []struct {
		name    string
		fields  fields
		wantErr bool
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			f := &vfsgen۰CompressedFile{
				vfsgen۰CompressedFileInfo: tt.fields.vfsgen۰CompressedFileInfo,
				gr:      tt.fields.gr,
				grPos:   tt.fields.grPos,
				seekPos: tt.fields.seekPos,
			}
			if err := f.Close(); (err != nil) != tt.wantErr {
				t.Errorf("vfsgen۰CompressedFile.Close() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func Test_vfsgen۰DirInfo_Read(t *testing.T) {
	type fields struct {
		name    string
		modTime time.Time
		entries []os.FileInfo
	}
	type args struct {
		in0 []byte
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		want    int
		wantErr bool
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			d := &vfsgen۰DirInfo{
				name:    tt.fields.name,
				modTime: tt.fields.modTime,
				entries: tt.fields.entries,
			}
			got, err := d.Read(tt.args.in0)
			if (err != nil) != tt.wantErr {
				t.Errorf("vfsgen۰DirInfo.Read() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if got != tt.want {
				t.Errorf("vfsgen۰DirInfo.Read() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_vfsgen۰DirInfo_Close(t *testing.T) {
	type fields struct {
		name    string
		modTime time.Time
		entries []os.FileInfo
	}
	tests := []struct {
		name    string
		fields  fields
		wantErr bool
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			d := &vfsgen۰DirInfo{
				name:    tt.fields.name,
				modTime: tt.fields.modTime,
				entries: tt.fields.entries,
			}
			if err := d.Close(); (err != nil) != tt.wantErr {
				t.Errorf("vfsgen۰DirInfo.Close() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func Test_vfsgen۰DirInfo_Stat(t *testing.T) {
	type fields struct {
		name    string
		modTime time.Time
		entries []os.FileInfo
	}
	tests := []struct {
		name    string
		fields  fields
		want    os.FileInfo
		wantErr bool
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			d := &vfsgen۰DirInfo{
				name:    tt.fields.name,
				modTime: tt.fields.modTime,
				entries: tt.fields.entries,
			}
			got, err := d.Stat()
			if (err != nil) != tt.wantErr {
				t.Errorf("vfsgen۰DirInfo.Stat() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("vfsgen۰DirInfo.Stat() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_vfsgen۰DirInfo_Name(t *testing.T) {
	type fields struct {
		name    string
		modTime time.Time
		entries []os.FileInfo
	}
	tests := []struct {
		name   string
		fields fields
		want   string
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			d := &vfsgen۰DirInfo{
				name:    tt.fields.name,
				modTime: tt.fields.modTime,
				entries: tt.fields.entries,
			}
			if got := d.Name(); got != tt.want {
				t.Errorf("vfsgen۰DirInfo.Name() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_vfsgen۰DirInfo_Size(t *testing.T) {
	type fields struct {
		name    string
		modTime time.Time
		entries []os.FileInfo
	}
	tests := []struct {
		name   string
		fields fields
		want   int64
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			d := &vfsgen۰DirInfo{
				name:    tt.fields.name,
				modTime: tt.fields.modTime,
				entries: tt.fields.entries,
			}
			if got := d.Size(); got != tt.want {
				t.Errorf("vfsgen۰DirInfo.Size() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_vfsgen۰DirInfo_Mode(t *testing.T) {
	type fields struct {
		name    string
		modTime time.Time
		entries []os.FileInfo
	}
	tests := []struct {
		name   string
		fields fields
		want   os.FileMode
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			d := &vfsgen۰DirInfo{
				name:    tt.fields.name,
				modTime: tt.fields.modTime,
				entries: tt.fields.entries,
			}
			if got := d.Mode(); got != tt.want {
				t.Errorf("vfsgen۰DirInfo.Mode() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_vfsgen۰DirInfo_ModTime(t *testing.T) {
	type fields struct {
		name    string
		modTime time.Time
		entries []os.FileInfo
	}
	tests := []struct {
		name   string
		fields fields
		want   time.Time
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			d := &vfsgen۰DirInfo{
				name:    tt.fields.name,
				modTime: tt.fields.modTime,
				entries: tt.fields.entries,
			}
			if got := d.ModTime(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("vfsgen۰DirInfo.ModTime() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_vfsgen۰DirInfo_IsDir(t *testing.T) {
	type fields struct {
		name    string
		modTime time.Time
		entries []os.FileInfo
	}
	tests := []struct {
		name   string
		fields fields
		want   bool
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			d := &vfsgen۰DirInfo{
				name:    tt.fields.name,
				modTime: tt.fields.modTime,
				entries: tt.fields.entries,
			}
			if got := d.IsDir(); got != tt.want {
				t.Errorf("vfsgen۰DirInfo.IsDir() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_vfsgen۰DirInfo_Sys(t *testing.T) {
	type fields struct {
		name    string
		modTime time.Time
		entries []os.FileInfo
	}
	tests := []struct {
		name   string
		fields fields
		want   interface{}
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			d := &vfsgen۰DirInfo{
				name:    tt.fields.name,
				modTime: tt.fields.modTime,
				entries: tt.fields.entries,
			}
			if got := d.Sys(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("vfsgen۰DirInfo.Sys() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_vfsgen۰Dir_Seek(t *testing.T) {
	type fields struct {
		vfsgen۰DirInfo *vfsgen۰DirInfo
		pos            int
	}
	type args struct {
		offset int64
		whence int
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		want    int64
		wantErr bool
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			d := &vfsgen۰Dir{
				vfsgen۰DirInfo: tt.fields.vfsgen۰DirInfo,
				pos:            tt.fields.pos,
			}
			got, err := d.Seek(tt.args.offset, tt.args.whence)
			if (err != nil) != tt.wantErr {
				t.Errorf("vfsgen۰Dir.Seek() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if got != tt.want {
				t.Errorf("vfsgen۰Dir.Seek() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_vfsgen۰Dir_Readdir(t *testing.T) {
	type fields struct {
		vfsgen۰DirInfo *vfsgen۰DirInfo
		pos            int
	}
	type args struct {
		count int
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		want    []os.FileInfo
		wantErr bool
	}{
	// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			d := &vfsgen۰Dir{
				vfsgen۰DirInfo: tt.fields.vfsgen۰DirInfo,
				pos:            tt.fields.pos,
			}
			got, err := d.Readdir(tt.args.count)
			if (err != nil) != tt.wantErr {
				t.Errorf("vfsgen۰Dir.Readdir() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("vfsgen۰Dir.Readdir() = %v, want %v", got, tt.want)
			}
		})
	}
}
